/*
 * Pulsar Admin REST API
 *
 * This provides the REST API for admin operations
 *
 * API version: v2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"fmt"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// NonPersistentTopicApiService NonPersistentTopicApi service
type NonPersistentTopicApiService service

// CompactOpts Optional parameters for the method 'Compact'
type CompactOpts struct {
    Authoritative optional.Bool
}

/*
Compact Trigger a compaction operation on a topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *CompactOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) Compact(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *CompactOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// CompactionStatusOpts Optional parameters for the method 'CompactionStatus'
type CompactionStatusOpts struct {
    Authoritative optional.Bool
}

/*
CompactionStatus Get the status of a compaction operation for a topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *CompactionStatusOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return LongRunningProcessStatus
*/
func (a *NonPersistentTopicApiService) CompactionStatus(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *CompactionStatusOpts) (LongRunningProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LongRunningProcessStatus
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LongRunningProcessStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CreateNonPartitionedTopicOpts Optional parameters for the method 'CreateNonPartitionedTopic'
type CreateNonPartitionedTopicOpts struct {
    Authoritative optional.Bool
}

/*
CreateNonPartitionedTopic Create a non-partitioned topic.
This is the only REST endpoint from which non-partitioned topics could be created.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *CreateNonPartitionedTopicOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) CreateNonPartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *CreateNonPartitionedTopicOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
CreatePartitionedTopic Create a partitioned topic.
It needs to be called before creating a producer on a partitioned topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param body The number of partitions for the topic
*/
func (a *NonPersistentTopicApiService) CreatePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string, body int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// CreateSubscriptionOpts Optional parameters for the method 'CreateSubscription'
type CreateSubscriptionOpts struct {
    Authoritative optional.Bool
    Replicated optional.Bool
}

/*
CreateSubscription Reset subscription to message position closest to given position.
Creates a subscription on the topic at the specified message id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subscriptionName Subscription to create position on
 * @param optional nil or *CreateSubscriptionOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  messageId where to create the subscription. It can be 'latest', 'earliest' or (ledgerId:entryId)
 * @param "Replicated" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) CreateSubscription(ctx _context.Context, tenant string, namespace string, topic string, subscriptionName string, localVarOptionals *CreateSubscriptionOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriptionName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subscriptionName)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Replicated.IsSet() {
		localVarQueryParams.Add("replicated", parameterToString(localVarOptionals.Replicated.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// DeletePartitionedTopicOpts Optional parameters for the method 'DeletePartitionedTopic'
type DeletePartitionedTopicOpts struct {
    Force optional.Bool
    Authoritative optional.Bool
}

/*
DeletePartitionedTopic Delete a partitioned topic.
It will also delete all the partitions of the topic if it exists.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *DeletePartitionedTopicOpts - Optional Parameters:
 * @param "Force" (optional.Bool) -  Stop all producer/consumer/replicator and delete topic forcefully
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) DeletePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *DeletePartitionedTopicOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Force.IsSet() {
		localVarQueryParams.Add("force", parameterToString(localVarOptionals.Force.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// DeleteSubscriptionOpts Optional parameters for the method 'DeleteSubscription'
type DeleteSubscriptionOpts struct {
    Authoritative optional.Bool
}

/*
DeleteSubscription Delete a subscription.
There should not be any active consumers on the subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Subscription to be deleted
 * @param optional nil or *DeleteSubscriptionOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) DeleteSubscription(ctx _context.Context, tenant string, namespace string, topic string, subName string, localVarOptionals *DeleteSubscriptionOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// DeleteTopicOpts Optional parameters for the method 'DeleteTopic'
type DeleteTopicOpts struct {
    Force optional.Bool
    Authoritative optional.Bool
}

/*
DeleteTopic Delete a topic.
The topic cannot be deleted if delete is not forcefully and there&#39;s any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *DeleteTopicOpts - Optional Parameters:
 * @param "Force" (optional.Bool) -  Stop all producer/consumer/replicator and delete topic forcefully
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) DeleteTopic(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *DeleteTopicOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Force.IsSet() {
		localVarQueryParams.Add("force", parameterToString(localVarOptionals.Force.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ExpireMessagesForAllSubscriptionsOpts Optional parameters for the method 'ExpireMessagesForAllSubscriptions'
type ExpireMessagesForAllSubscriptionsOpts struct {
    Authoritative optional.Bool
}

/*
ExpireMessagesForAllSubscriptions Expiry messages on all subscriptions of topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param expireTimeInSeconds Expires beyond the specified number of seconds
 * @param optional nil or *ExpireMessagesForAllSubscriptionsOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) ExpireMessagesForAllSubscriptions(ctx _context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, localVarOptionals *ExpireMessagesForAllSubscriptionsOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", expireTimeInSeconds)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ExpireTopicMessagesOpts Optional parameters for the method 'ExpireTopicMessages'
type ExpireTopicMessagesOpts struct {
    Authoritative optional.Bool
}

/*
ExpireTopicMessages Expiry messages on a topic subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Subscription to be Expiry messages on
 * @param expireTimeInSeconds Expires beyond the specified number of seconds
 * @param optional nil or *ExpireTopicMessagesOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) ExpireTopicMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, localVarOptionals *ExpireTopicMessagesOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expireTimeInSeconds"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", expireTimeInSeconds)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetBacklogOpts Optional parameters for the method 'GetBacklog'
type GetBacklogOpts struct {
    Authoritative optional.Bool
}

/*
GetBacklog Get estimated backlog for offline topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetBacklogOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return PersistentOfflineTopicStats
*/
func (a *NonPersistentTopicApiService) GetBacklog(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetBacklogOpts) (PersistentOfflineTopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentOfflineTopicStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/backlog"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v PersistentOfflineTopicStats
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetInternalStatsOpts Optional parameters for the method 'GetInternalStats'
type GetInternalStatsOpts struct {
    Authoritative optional.Bool
}

/*
GetInternalStats Get the internal stats for the topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetInternalStatsOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return PersistentTopicInternalStats
*/
func (a *NonPersistentTopicApiService) GetInternalStats(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetInternalStatsOpts) (PersistentTopicInternalStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PersistentTopicInternalStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/internalStats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v PersistentTopicInternalStats
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetLastMessageIdOpts Optional parameters for the method 'GetLastMessageId'
type GetLastMessageIdOpts struct {
    Authoritative optional.Bool
}

/*
GetLastMessageId Return the last commit message id of topic
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetLastMessageIdOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return map[string]interface{}
*/
func (a *NonPersistentTopicApiService) GetLastMessageId(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetLastMessageIdOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/lastMessageId"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetList Get the list of non-persistent topics under a namespace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
@return []string
*/
func (a *NonPersistentTopicApiService) GetList(ctx _context.Context, tenant string, namespace string) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetListFromBundle Get the list of non-persistent topics under a namespace bundle.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param bundle Bundle range of a topic
@return []string
*/
func (a *NonPersistentTopicApiService) GetListFromBundle(ctx _context.Context, tenant string, namespace string, bundle string) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{bundle}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"bundle"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", bundle)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetManagedLedgerInfo Get the internal stats for the topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
*/
func (a *NonPersistentTopicApiService) GetManagedLedgerInfo(ctx _context.Context, tenant string, namespace string, topic string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/internal-info"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetPartitionedMetadataOpts Optional parameters for the method 'GetPartitionedMetadata'
type GetPartitionedMetadataOpts struct {
    Authoritative optional.Bool
    CheckAllowAutoCreation optional.Bool
}

/*
GetPartitionedMetadata Get partitioned topic metadata.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetPartitionedMetadataOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
 * @param "CheckAllowAutoCreation" (optional.Bool) -  Is check configuration required to automatically create topic
@return PartitionedTopicMetadata
*/
func (a *NonPersistentTopicApiService) GetPartitionedMetadata(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetPartitionedMetadataOpts) (PartitionedTopicMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PartitionedTopicMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CheckAllowAutoCreation.IsSet() {
		localVarQueryParams.Add("checkAllowAutoCreation", parameterToString(localVarOptionals.CheckAllowAutoCreation.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v PartitionedTopicMetadata
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPartitionedStatsOpts Optional parameters for the method 'GetPartitionedStats'
type GetPartitionedStatsOpts struct {
    PerPartition optional.Bool
    Authoritative optional.Bool
}

/*
GetPartitionedStats Get the stats for the partitioned topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetPartitionedStatsOpts - Optional Parameters:
 * @param "PerPartition" (optional.Bool) -  Get per partition stats
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) GetPartitionedStats(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetPartitionedStatsOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitioned-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PerPartition.IsSet() {
		localVarQueryParams.Add("perPartition", parameterToString(localVarOptionals.PerPartition.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetPartitionedTopicList Get the list of partitioned topics under a namespace.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
@return []string
*/
func (a *NonPersistentTopicApiService) GetPartitionedTopicList(ctx _context.Context, tenant string, namespace string) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/partitioned"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetPermissionsOnTopic Get permissions on a topic.
Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
@return map[string]map[string]interface{}
*/
func (a *NonPersistentTopicApiService) GetPermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string) (map[string]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetStatsOpts Optional parameters for the method 'GetStats'
type GetStatsOpts struct {
    Authoritative optional.Bool
}

/*
GetStats Get the stats for the topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetStatsOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return NonPersistentTopicStats
*/
func (a *NonPersistentTopicApiService) GetStats(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetStatsOpts) (NonPersistentTopicStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NonPersistentTopicStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NonPersistentTopicStats
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetSubscriptionsOpts Optional parameters for the method 'GetSubscriptions'
type GetSubscriptionsOpts struct {
    Authoritative optional.Bool
}

/*
GetSubscriptions Get the list of persistent subscriptions for a given topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *GetSubscriptionsOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) GetSubscriptions(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *GetSubscriptionsOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GrantPermissionsOnTopicOpts Optional parameters for the method 'GrantPermissionsOnTopic'
type GrantPermissionsOnTopicOpts struct {
    Body optional.Interface
}

/*
GrantPermissionsOnTopic Grant a new permission to a role on a single topic.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param role Client role to which grant permissions
 * @param optional nil or *GrantPermissionsOnTopicOpts - Optional Parameters:
 * @param "Body" (optional.Interface of []string) -  Actions to be granted (produce,functions,consume)
*/
func (a *NonPersistentTopicApiService) GrantPermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string, role string, localVarOptionals *GrantPermissionsOnTopicOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", role)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarOptionalBody, localVarOptionalBodyok := localVarOptionals.Body.Value().([]string)
		if !localVarOptionalBodyok {
			return nil, reportError("body should be []string")
		}
		localVarPostBody = &localVarOptionalBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// OffloadStatusOpts Optional parameters for the method 'OffloadStatus'
type OffloadStatusOpts struct {
    Authoritative optional.Bool
}

/*
OffloadStatus Offload a prefix of a topic to long term storage
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *OffloadStatusOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return OffloadProcessStatus
*/
func (a *NonPersistentTopicApiService) OffloadStatus(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *OffloadStatusOpts) (OffloadProcessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OffloadProcessStatus
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v OffloadProcessStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PeekNthMessageOpts Optional parameters for the method 'PeekNthMessage'
type PeekNthMessageOpts struct {
    Authoritative optional.Bool
}

/*
PeekNthMessage Peek nth message on a topic subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Subscribed message expired
 * @param messagePosition The number of messages (default 1)
 * @param optional nil or *PeekNthMessageOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) PeekNthMessage(ctx _context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, localVarOptionals *PeekNthMessageOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messagePosition"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", messagePosition)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ResetCursorOpts Optional parameters for the method 'ResetCursor'
type ResetCursorOpts struct {
    Authoritative optional.Bool
}

/*
ResetCursor Reset subscription to message position closest to absolute timestamp (in ms).
It fence cursor and disconnects all active consumers before reseting cursor.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Subscription to reset position on
 * @param timestamp time in minutes to reset back to (or minutes, hours,days,weeks eg:100m, 3h, 2d, 5w)
 * @param optional nil or *ResetCursorOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) ResetCursor(ctx _context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, localVarOptionals *ResetCursorOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"timestamp"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", timestamp)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ResetCursorOnPositionOpts Optional parameters for the method 'ResetCursorOnPosition'
type ResetCursorOnPositionOpts struct {
    Authoritative optional.Bool
    MessageId optional.Interface
}

/*
ResetCursorOnPosition Reset subscription to message position closest to given position.
It fence cursor and disconnects all active consumers before reseting cursor.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Subscription to reset position on
 * @param optional nil or *ResetCursorOnPositionOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
 * @param "MessageId" (optional.Interface of MessageIdImpl) -  messageId to reset back to (ledgerId:entryId)
*/
func (a *NonPersistentTopicApiService) ResetCursorOnPosition(ctx _context.Context, tenant string, namespace string, topic string, subName string, localVarOptionals *ResetCursorOnPositionOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.MessageId.IsSet() {
		localVarOptionalMessageId, localVarOptionalMessageIdok := localVarOptionals.MessageId.Value().(MessageIdImpl)
		if !localVarOptionalMessageIdok {
			return nil, reportError("messageId should be MessageIdImpl")
		}
		localVarPostBody = &localVarOptionalMessageId
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
RevokePermissionsOnTopic Revoke permissions on a topic.
Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param role Client role to which grant permissions
*/
func (a *NonPersistentTopicApiService) RevokePermissionsOnTopic(ctx _context.Context, tenant string, namespace string, topic string, role string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", role)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SkipAllMessagesOpts Optional parameters for the method 'SkipAllMessages'
type SkipAllMessagesOpts struct {
    Authoritative optional.Bool
}

/*
SkipAllMessages Skip all messages on a topic subscription.
Completely clears the backlog on the subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Name of subscription
 * @param optional nil or *SkipAllMessagesOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) SkipAllMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string, localVarOptionals *SkipAllMessagesOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SkipMessagesOpts Optional parameters for the method 'SkipMessages'
type SkipMessagesOpts struct {
    Authoritative optional.Bool
}

/*
SkipMessages Skipping messages on a topic subscription.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param subName Name of subscription
 * @param numMessages The number of messages to skip
 * @param optional nil or *SkipMessagesOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) SkipMessages(ctx _context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, localVarOptionals *SkipMessagesOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subName"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", subName)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"numMessages"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", numMessages)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// TerminateOpts Optional parameters for the method 'Terminate'
type TerminateOpts struct {
    Authoritative optional.Bool
}

/*
Terminate Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *TerminateOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
@return map[string]interface{}
*/
func (a *NonPersistentTopicApiService) Terminate(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *TerminateOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/terminate"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TriggerOffloadOpts Optional parameters for the method 'TriggerOffload'
type TriggerOffloadOpts struct {
    Authoritative optional.Bool
}

/*
TriggerOffload Offload a prefix of a topic to long term storage
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *TriggerOffloadOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) TriggerOffload(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *TriggerOffloadOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/offload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// UnloadTopicOpts Optional parameters for the method 'UnloadTopic'
type UnloadTopicOpts struct {
    Authoritative optional.Bool
}

/*
UnloadTopic Unload a topic
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param optional nil or *UnloadTopicOpts - Optional Parameters:
 * @param "Authoritative" (optional.Bool) -  Is authentication required to perform this operation
*/
func (a *NonPersistentTopicApiService) UnloadTopic(ctx _context.Context, tenant string, namespace string, topic string, localVarOptionals *UnloadTopicOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/unload"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Authoritative.IsSet() {
		localVarQueryParams.Add("authoritative", parameterToString(localVarOptionals.Authoritative.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
UpdatePartitionedTopic Increment partitons of an existing partitioned topic.
It only increments partitions of existing non-global partitioned-topic
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param tenant Specify the tenant
 * @param namespace Specify the namespace
 * @param topic Specify topic name
 * @param body The number of partitions for the topic
*/
func (a *NonPersistentTopicApiService) UpdatePartitionedTopic(ctx _context.Context, tenant string, namespace string, topic string, body int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"tenant"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", tenant)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", namespace)), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"topic"+"}", _neturl.QueryEscape(fmt.Sprintf("%v", topic)), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &body
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
